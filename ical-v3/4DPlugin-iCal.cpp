/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-iCal.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : iCal
 #	author : miyako
 #	2020/03/17
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-iCal.h"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#pragma mark Permission

std::mutex mutex_permission;

request_permission_t granted_permission = request_permission_unknown;

BOOL check_permission(PA_ObjectRef status) {
    
    BOOL returnValue = false;
    
    if(status) {
        
        switch (granted_permission) {
                
            case request_permission_authorized:
                returnValue = true;
                ob_set_b(status, L"success", returnValue);
                break;
                
            case request_permission_denied:
                returnValue = false;
                ob_set_b(status, L"success", returnValue);
                ob_set_s(status, L"errorMessage", "permission denied");
                return false;
                break;
                
            case request_permission_restricted:
                returnValue = false;
                ob_set_b(status, L"success", returnValue);
                ob_set_s(status, L"errorMessage", "permission restricted");
                break;
                
            case request_permission_not_determined:
                returnValue = false;
                ob_set_b(status, L"success", returnValue);
                ob_set_s(status, L"errorMessage", "permission not determined");
                break;
                
            default:
                break;
        }
    }
    
    return returnValue;
}

request_permission_t requestPermission(void) {
    
    std::lock_guard<std::mutex> lock(mutex_permission);
    
    if (@available(macOS 10.9, *)) {
        
        switch ([EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent])
        {
            case EKAuthorizationStatusNotDetermined:
            {
                EKEventStore *store = [EKEventStore new];
                [store requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) {
                    if (granted) {
                        granted_permission = request_permission_authorized;
                    }
                }];
                granted_permission = request_permission_not_determined;
                break;
            }
            break;
                
            case EKAuthorizationStatusRestricted:
                granted_permission = request_permission_restricted;
                break;
                
            case EKAuthorizationStatusDenied:
                granted_permission = request_permission_denied;
                break;
                
            case EKAuthorizationStatusAuthorized:
                granted_permission = request_permission_authorized;
                break;
        }

    }
    
    return granted_permission;
}

void iCal_Request_permisson(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();
    
    NSBundle *mainBundle = [NSBundle mainBundle];
    if(mainBundle) {
        NSDictionary *infoDictionary = [mainBundle infoDictionary];
        if(infoDictionary) {
            NSString *calendarUsageDescription = [infoDictionary objectForKey:@"NSCalendarsUsageDescription"];
            if(calendarUsageDescription) {
             
                SecTaskRef sec = SecTaskCreateFromSelf(kCFAllocatorMalloc);
                CFErrorRef err = nil;
                CFBooleanRef boolValue = (CFBooleanRef)SecTaskCopyValueForEntitlement(sec,
                                                                                      CFSTR("com.apple.security.personal-information.calendars"),
                                                                                      &err);
                if((!err) && (boolValue)){
                    if(boolValue) {
                        if(CFBooleanGetValue(boolValue)) {
                             
                            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)requestPermission, NULL);
                            
                            check_permission(status);
 
                        }else{
                            ob_set_b(status, L"success", false);
                            ob_set_s(status, L"errorMessage", "com.apple.security.personal-information.calendars is set to false in app entitlement");
                        }
                        CFRelease(boolValue);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "com.apple.security.personal-information.calendars is missing in app entitlement");
                }
                CFRelease(sec);
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "NScalendarUsageDescription is missing in app info.plist");
            }
        }else{
            ob_set_b(status, L"success", false);
            ob_set_s(status, L"errorMessage", "failed to locate [mainBundle infoDictionary]");
        }
    }else{
        ob_set_b(status, L"success", false);
        ob_set_s(status, L"errorMessage", "failed to locate [NSBundle mainBundle]");
    }
    
    PA_ReturnObject(params, status);
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- iCal
            
			case 1 :
				iCal_Request_permisson(params);
				break;
            case 2 :
                iCal_QUERY_EVENT(params);
                break;
            case 3 :
                iCal_GET_CALENDAR_LIST(params);
                break;
                
            case 4 :
                iCal_Create_calendar(params);
                break;
            case 5 :
                iCal_Set_calendar_property(params);
                break;
            case 6 :
                iCal_Get_calendar_property(params);
                break;
            case 7 :
                iCal_Remove_calendar(params);
                break;
                
            case 8 :
                iCal_Create_event(params);
                break;
            case 9 :
                iCal_Set_event_property(params);
                break;
            case 10 :
                iCal_Get_event_property(params);
                break;
            case 11 :
                iCal_Remove_event(params);
                break;
                
            case 12 :
                iCal_Get_default_calendar(params);
                break;
                
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

NSColor *getRGBcolor(unsigned int rgb) {
    
    NSColor *color = NULL;
    
    CGFloat red, green, blue;
    
    red     = (CGFloat)(((rgb & 0x00FF0000) >> 16  ) / 0xFF);
    green   = (CGFloat)(((rgb & 0x0000FF00) >> 8   ) / 0xFF);
    blue    = (CGFloat)(((rgb & 0x000000FF)        ) / 0xFF);
    
    color = [NSColor colorWithDeviceRed:red
                                  green:green
                                   blue:blue
                                  alpha:1.0f];
    
    return color;
}

unsigned int getColorRGB(NSColor *color) {
    
    unsigned int rgb = 0;
    
    if(color)
    {
        color = [color colorUsingColorSpace:[NSColorSpace displayP3ColorSpace]];
        
        /*
         color = [color colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];//NSDeviceRGBColorSpace
         color = [color colorUsingColorSpace:[NSColorSpace sRGBColorSpace]];
         color = [color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];//NSCalibratedRGBColorSpace
         */
        
        CGFloat red, green, blue, alpha;
        [color getRed:&red green:&green blue:&blue alpha:&alpha];
        
        rgb +=
        
        /*
         +((unsigned int)(red      * 255.99999f) << 16)
         +((unsigned int)(green    * 255.99999f) << 8)
         + (unsigned int)(blue     * 255.99999f);
         */
        
        +((unsigned int)floor((CGFloat)(red      * 0xFF) + 0.5f) << 16)
        +((unsigned int)floor((CGFloat)(green    * 0xFF) + 0.5f) << 8)
        + (unsigned int)floor((CGFloat)(blue     * 0xFF) + 0.5f);
    }
    
    return rgb;
}

#pragma mark Calendar / PA_ObjectRef

void ob_set_calendar(PA_ObjectRef status,
#if USE_EK_CALENDAR_ITEM
                     EKCalendar *calendar
#else
                     CalCalendar *calendar
#endif
                     ) {
    
    if(status) {
        
        ob_set_v(status, L"title", calendar.title);

#if USE_EK_CALENDAR_ITEM
                    ob_set_v(status, L"uid", calendar.calendarIdentifier);
                    ob_set_n(status, L"color", calendar.color ? getColorRGB(calendar.color) : 0L);
/* notes not supported in EK */
        
        switch (calendar.type) {
            case EKCalendarTypeLocal:
                ob_set_v(status, L"type", @"Local");
                break;
            case EKCalendarTypeCalDAV:
                ob_set_v(status, L"type", @"CalDAV");
                break;
            case EKCalendarTypeExchange:
                ob_set_v(status, L"type", @"Exchange");
                break;
            case EKCalendarTypeSubscription:
                ob_set_v(status, L"type", @"Subscription");
                break;
            case EKCalendarTypeBirthday:
                ob_set_v(status, L"type", @"Birthday");
                break;
            default:
                /* CalCalendarTypeIMAP not supported in EK */
                break;
        }

        ob_set_b(status, L"subscribed", calendar.subscribed);
        ob_set_b(status, L"immutable", calendar.immutable);
        ob_set_b(status, L"allowsContentModifications", calendar.allowsContentModifications);
#else
        ob_set_v(status, L"uid", calendar.uid);
        ob_set_v(status, L"notes", calendar.notes);
        ob_set_v(status, L"type", calendar.type);
        ob_set_b(status, L"isEditable", calendar.isEditable);
#endif
        
    }
    
}

NSArray *ob_get_calendars(PA_ObjectRef options,
#if USE_EK_CALENDAR_ITEM
                          EKEventStore *calendarStore
#else
                          CalCalendarStore *calendarStore
#endif
                          ) {
    
    NSMutableArray *value = nil;
    
    if(options){
        if(calendarStore){
            PA_CollectionRef calendars = ob_get_c(options, L"calendars");
            if(calendars){
                value = [[NSMutableArray alloc]init];
                for(PA_long32 i = 0; i < PA_GetCollectionLength(calendars); ++i){
                    PA_Variable v = PA_GetCollectionElement(calendars, i);
                    if(PA_GetVariableKind(v) == eVK_Object){
                        PA_ObjectRef o = PA_GetObjectVariable(v);
                        if(o){
                            NSString *uid = ob_get_v(o, L"uid");
                            if(uid){
#if USE_EK_CALENDAR_ITEM
                                EKCalendar *calendar = [calendarStore calendarWithIdentifier:uid];
#else
                                CalCalendar *calendar = [calendarStore calendarWithUID:uid];
#endif
                                if(calendar){
                                    [value addObject:calendar];
                                }
                            }else{
                                NSString *title = ob_get_v(o, L"title");
                                if(title){
#if USE_EK_CALENDAR_ITEM
                                    NSArray *_calendars = [calendarStore calendarsForEntityType:EKEntityTypeEvent];
#else
                                    NSArray *_calendars = [calendarStore calendars];
#endif
                                    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"title LIKE %@", title];
                                    _calendars = [_calendars filteredArrayUsingPredicate:predicate];
                                    if([_calendars count]){
                                        [value addObject:[_calendars objectAtIndex:0]];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return value;
}

#pragma mark -
#if USE_EK_CALENDAR_ITEM
EKEvent *
#else
CalEvent *
#endif
ob_get_event(PA_ObjectRef options,
#if USE_EK_CALENDAR_ITEM
                      EKEventStore *calendarStore
#else
                      CalCalendarStore *calendarStore
#endif
                      ) {
 
    EKEvent *value = nil;
        
    if(options){
        if(calendarStore){
            NSString *uid = ob_get_v(options, L"uid");
            if(uid){
#if USE_EK_CALENDAR_ITEM
                NSArray *values = [calendarStore calendarItemsWithExternalIdentifier:uid];
                if([values count]) {
                    value = [values objectAtIndex:0];
                }
#else
                if(uid){
                    NSDate *occurrence = ob_get_d(options, L"occurrence");
                    value = [calendarStore eventWithUID:uid occurrence:occurrence];
                }
#endif
            }
        }
    }
    return value;
}

#if USE_EK_CALENDAR_ITEM
EKCalendar *
#else
CalCalendar *
#endif
ob_get_calendar(PA_ObjectRef options,
#if USE_EK_CALENDAR_ITEM
                EKEventStore     *calendarStore
#else
                CalCalendarStore *calendarStore
#endif
                ) {
                    
#if USE_EK_CALENDAR_ITEM
                    EKCalendar  *value = nil;
#else
                    CalCalendar *value = nil;
#endif
    if(options){
        if(calendarStore){
            NSString *uid = ob_get_v(options, L"uid");
            if(uid){
#if USE_EK_CALENDAR_ITEM
                value = [calendarStore calendarWithIdentifier:uid];
                
#else
                value = [calendarStore calendarWithUID:uid];
#endif
            }else{
                NSString *title = ob_get_v(options, L"title");
                if(title){
#if USE_EK_CALENDAR_ITEM
                    NSArray<EKCalendar *> *_calendars = [calendarStore calendarsForEntityType:EKEntityTypeEvent];
                    
#else
                    NSArray<CalCalendar > *_calendars = [calendarStore calendars];
#endif
                    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"title LIKE %@", title];
                    _calendars = [_calendars filteredArrayUsingPredicate:predicate];
                    if([_calendars count]){
                        value = [_calendars objectAtIndex:0];
                    }
                }
            }
        }
    }
    return value;
}

void ob_set_event_calendar(PA_ObjectRef status,
#if USE_EK_CALENDAR_ITEM
                           EKEvent *event
#else
                           CalEvent *event
#endif
                           ) {
    
    if(status){
        
        PA_ObjectRef _calendar = PA_CreateObject();
        
        if(event){
#if USE_EK_CALENDAR_ITEM
            EKCalendar *calendar = event.calendar;
#else
            CalCalendar *calendar = event.calendar;
#endif
            if(calendar){
                ob_set_calendar(_calendar, calendar);
            }
        }
        
        ob_set_o(status, L"calendar", _calendar);
    }
}

void ob_set_event_prop(PA_ObjectRef status, PA_ObjectRef options,
                       
#if USE_EK_CALENDAR_ITEM
                       EKEvent *event
#else
                       CalEvent *event
#endif
                       ) {

    if(status){
        if(options){
            if(event){
                
                NSDate *startDate = ob_get_d(options, L"startDate");
                NSDate *endDate = ob_get_d(options, L"endDate");
                
                if(startDate){
                    if(endDate){
                        
                        event.startDate = startDate;
                        event.endDate = endDate;
                        
                        NSString *title = ob_get_v(options, L"title");
                        
                        if(title){
                            event.title = title;
                            [title release];
                        }
                        
                        NSString *location = ob_get_v(options, L"location");
                        
                        if(location){
                            event.location = location;
                            [location release];
                        }
                        
                        NSString *notes = ob_get_v(options, L"notes");
                        
                        if(notes){
                            event.notes = notes;
                            [notes release];
                        }
                        
                        if(ob_is_defined(options, L"isAllDay")){
#if USE_EK_CALENDAR_ITEM
                            event.allDay = ob_get_b(options, L"isAllDay");
#else
                            event.isAllDay = ob_get_b(options, L"isAllDay");
#endif
                        }
                        
                        NSString *url = ob_get_v(options, L"url");
                        
                        if(url){
                            NSURL *_url = [[NSURL alloc]initWithString:url];
                            if(_url){
#if USE_EK_CALENDAR_ITEM
                                event.URL = _url;
#else
                                event.url = _url;
#endif
                            }
                            [url release];
                        }
                        
                        if(ob_is_defined(options, L"recurrenceRule")){
                            
                            PA_ObjectRef _recurrenceRule = ob_get_o(options, L"recurrenceRule");
                            if(_recurrenceRule){
#if USE_EK_CALENDAR_ITEM
                                EKRecurrenceEnd *recurrenceEnd = nil;
#else
                                CalRecurrenceEnd *recurrenceEnd = nil;
                                NSUInteger dayOfTheWeek = 0;
                                NSUInteger weekOfTheMonth = 0;
#endif
                                NSDate *endDate = nil;
                                NSUInteger occurrenceCount = 0;
                                NSUInteger recurrenceInterval = 0;

#if USE_EK_CALENDAR_ITEM
                                EKRecurrenceFrequency recurrenceType = EKRecurrenceFrequencyDaily;
#else
                                CalRecurrenceType recurrenceType = CalRecurrenceDaily;
#endif
                                if(ob_is_defined(_recurrenceRule, L"recurrenceType")){
#if USE_EK_CALENDAR_ITEM
                                    recurrenceType = (EKRecurrenceFrequency)ob_get_n(_recurrenceRule, L"recurrenceType");
#else
                                    recurrenceType = (CalRecurrenceType)ob_get_n(_recurrenceRule, L"recurrenceType");
#endif
                                }
                                
                                if(ob_is_defined(_recurrenceRule, L"recurrenceInterval")){
                                    recurrenceInterval = (NSUInteger)ob_get_n(_recurrenceRule, L"recurrenceInterval");
                                }
                                
                                
#if USE_EK_CALENDAR_ITEM
#else
                                if(ob_is_defined(_recurrenceRule, L"dayOfTheWeek")){
                                    dayOfTheWeek = (NSUInteger)ob_get_n(_recurrenceRule, L"dayOfTheWeek");
                                }
                                if(ob_is_defined(_recurrenceRule, L"weekOfTheMonth")){
                                    weekOfTheMonth = (NSUInteger)ob_get_n(_recurrenceRule, L"weekOfTheMonth");
                                }
#endif

                                if(ob_is_defined(_recurrenceRule, L"recurrenceEnd")){
                                    PA_ObjectRef _recurrenceEnd = ob_get_o(_recurrenceRule, L"recurrenceEnd");
                                    if(_recurrenceEnd){
                                        endDate = ob_get_d(_recurrenceEnd, L"endDate");
                                        occurrenceCount = ob_get_n(_recurrenceEnd, L"occurrenceCount");
#if USE_EK_CALENDAR_ITEM
                                        if(endDate) {
                                            recurrenceEnd = [EKRecurrenceEnd recurrenceEndWithEndDate:endDate];
                                        }
                                        
                                        if(occurrenceCount > 0) {
                                            recurrenceEnd = [EKRecurrenceEnd recurrenceEndWithOccurrenceCount:occurrenceCount];
                                        }
#else
                                        if(endDate) {
                                            recurrenceEnd = [CalRecurrenceEnd recurrenceEndWithEndDate:endDate];
                                        }
                                        
                                        if(occurrenceCount > 0) {
                                            recurrenceEnd = [CalRecurrenceEnd recurrenceEndWithOccurrenceCount:occurrenceCount];
                                        }
#endif
                                    }
                                    
                                }
                                
                                NSMutableArray *daysOfTheWeek = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"daysOfTheWeek")){
                                    PA_CollectionRef _daysOfTheWeek = ob_get_c(_recurrenceRule, L"daysOfTheWeek");
                                    if(_daysOfTheWeek){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_daysOfTheWeek); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_daysOfTheWeek, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [daysOfTheWeek addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *daysOfTheMonth = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"daysOfTheMonth")){
                                    PA_CollectionRef _daysOfTheMonth = ob_get_c(_recurrenceRule, L"daysOfTheMonth");
                                    if(_daysOfTheMonth){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_daysOfTheMonth); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_daysOfTheMonth, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [daysOfTheMonth addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *monthsOfTheYear = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"monthsOfTheYear")){
                                    PA_CollectionRef _monthsOfTheYear = ob_get_c(_recurrenceRule, L"monthsOfTheYear");
                                    if(_monthsOfTheYear){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_monthsOfTheYear); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_monthsOfTheYear, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [monthsOfTheYear addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *weeksOfTheYear = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"weeksOfTheYear")){
                                    PA_CollectionRef _weeksOfTheYear = ob_get_c(_recurrenceRule, L"weeksOfTheYear");
                                    if(_weeksOfTheYear){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_weeksOfTheYear); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_weeksOfTheYear, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [weeksOfTheYear addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *daysOfTheYear = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"daysOfTheYear")){
                                    PA_CollectionRef _daysOfTheYear = ob_get_c(_recurrenceRule, L"daysOfTheYear");
                                    if(_daysOfTheYear){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_daysOfTheYear); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_daysOfTheYear, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [daysOfTheYear addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *setPositions = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"setPositions")){
                                    PA_CollectionRef _setPositions = ob_get_c(_recurrenceRule, L"setPositions");
                                    if(_setPositions){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_setPositions); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_setPositions, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [setPositions addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
#if USE_EK_CALENDAR_ITEM
                                EKRecurrenceRule *recurrenceRule = [[EKRecurrenceRule alloc]initRecurrenceWithFrequency:recurrenceType
                                                                                                               interval:recurrenceInterval
                                                                                                          daysOfTheWeek:[daysOfTheWeek count] ? daysOfTheWeek : nil
                                                                                                         daysOfTheMonth:[daysOfTheMonth count] ? daysOfTheMonth : nil
                                                                                                        monthsOfTheYear:[monthsOfTheYear count] ? monthsOfTheYear : nil
                                                                                                         weeksOfTheYear:[weeksOfTheYear count] ? weeksOfTheYear : nil
                                                                                                          daysOfTheYear:[daysOfTheYear count] ? daysOfTheYear : nil
                                                                                                           setPositions:[setPositions count] ? setPositions : nil
                                                                                                                    end:recurrenceEnd];
                                if(recurrenceRule) {
                                    [event addRecurrenceRule:recurrenceRule];
                                    [recurrenceRule release];
                                }
#else
                                switch (recurrenceType){
                                        
                                    case CalRecurrenceDaily:
                                    {
                                        CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initDailyRecurrenceWithInterval:recurrenceInterval
                                                                                                                                  end:recurrenceEnd];
                                        if(recurrenceRule) {
                                            event.recurrenceRule = recurrenceRule;
                                            [recurrenceRule release];
                                        }
                                        
                                    }
                                        break;
                                        
                                    case CalRecurrenceWeekly:
                                    {
                                        if([daysOfTheWeek count]){
                                            
                                            CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:recurrenceInterval
                                                                                                                          forDaysOfTheWeek:daysOfTheWeek
                                                                                                                                       end:recurrenceEnd];
                                            if(recurrenceRule) {
                                                event.recurrenceRule = recurrenceRule;
                                                [recurrenceRule release];
                                            }
                                            
                                        }else{
                                            CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initWeeklyRecurrenceWithInterval:recurrenceInterval
                                                                                                                                       end:recurrenceEnd];
                                            if(recurrenceRule) {
                                                event.recurrenceRule = recurrenceRule;
                                                [recurrenceRule release];
                                            }
                                            
                                        }
                                        
                                    }
                                        break;
                                        
                                    case CalRecurrenceMonthly:
                                    {
                                        if([daysOfTheMonth count]){
                                            CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:recurrenceInterval
                                                                                                                          forDaysOfTheMonth:daysOfTheMonth
                                                                                                                                        end:recurrenceEnd];
                                            if(recurrenceRule) {
                                                event.recurrenceRule = recurrenceRule;
                                                [recurrenceRule release];
                                            }
                                        }else{
                                            
                                            if(dayOfTheWeek && weekOfTheMonth){
                                                CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:recurrenceInterval
                                                                                                                                forDayOfTheWeek:dayOfTheWeek
                                                                                                                              forWeekOfTheMonth:weekOfTheMonth
                                                                                                                                            end:recurrenceEnd];
                                                if(recurrenceRule) {
                                                    event.recurrenceRule = recurrenceRule;
                                                    [recurrenceRule release];
                                                }
                                            }else{
                                                CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initMonthlyRecurrenceWithInterval:recurrenceInterval
                                                                                                                                            end:recurrenceEnd];
                                                if(recurrenceRule) {
                                                    event.recurrenceRule = recurrenceRule;
                                                    [recurrenceRule release];
                                                }
                                            }
                                        }
                                    }
                                        break;
                                    case CalRecurrenceYearly:
                                    {
                                        if([monthsOfTheYear count]){
                                            
                                            CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:recurrenceInterval
                                                                                                                           forDayOfTheWeek:dayOfTheWeek
                                                                                                                         forWeekOfTheMonth:weekOfTheMonth
                                                                                                                        forMonthsOfTheYear:monthsOfTheYear
                                                                                                                                       end:recurrenceEnd];
                                            if(recurrenceRule) {
                                                event.recurrenceRule = recurrenceRule;
                                                [recurrenceRule release];
                                            }
                                            
                                        }else{
                                            if([monthsOfTheYear count]){
                                                CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:recurrenceInterval
                                                                                                                            forMonthsOfTheYear:monthsOfTheYear
                                                                                                                                           end:recurrenceEnd];
                                                if(recurrenceRule) {
                                                    event.recurrenceRule = recurrenceRule;
                                                    [recurrenceRule release];
                                                }
                                            }else{
                                                CalRecurrenceRule *recurrenceRule = [[CalRecurrenceRule alloc]initYearlyRecurrenceWithInterval:recurrenceInterval
                                                                                                                                           end:recurrenceEnd];
                                                if(recurrenceRule) {
                                                    event.recurrenceRule = recurrenceRule;
                                                    [recurrenceRule release];
                                                }
                                            }
                                        }
                                    }
                                        break;
                                }
#endif
                                
                                [daysOfTheWeek release];
                                [daysOfTheMonth release];
                                [monthsOfTheYear release];
                                
                                [weeksOfTheYear release];
                                [daysOfTheYear release];
                                [setPositions release];

                            } else {
#if USE_EK_CALENDAR_ITEM
                                if([event hasRecurrenceRules]) {
                                    NSArray<EKRecurrenceRule *> *recurrenceRules = event.recurrenceRules;
                                    if(recurrenceRules) {
                                        if(recurrenceRules.count > 0) {
                                            EKRecurrenceRule *recurrenceRule = recurrenceRules.firstObject;
                                            [event removeRecurrenceRule:recurrenceRule];
                                        }
                                    }
                                }
#else
                                event.recurrenceRule = nil;
#endif
                            }
  
                        }
                        
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "invalid endDate");
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid startDate");
                }
            }
        }
    }
}

void ob_copy_event(PA_ObjectRef _event,
#if USE_EK_CALENDAR_ITEM
                   EKEvent *event,
#else
                   CalEvent *event,
#endif
                   BOOL with_calendar = TRUE) {
    
    if(_event){
        if(event){
            
#if USE_EK_CALENDAR_ITEM
            ob_set_v(_event, L"uid", event.calendarItemExternalIdentifier);
            ob_set_u(_event, L"url", event.URL);
            ob_set_d(_event, L"occurrence", event.occurrenceDate);
            ob_set_d(_event, L"dateStamp", event.lastModifiedDate);
            ob_set_d(_event, L"creationDate", event.creationDate);
            
            if(event.timeZone) {
                
                NSTimeZone *timezone = event.timeZone;
                
                PA_ObjectRef _timeZone = PA_CreateObject();
                
                ob_set_v(_timeZone, L"name", timezone.name);
                ob_set_v(_timeZone, L"abbreviation", timezone.abbreviation);
                ob_set_b(_timeZone, L"daylightSavingTime", timezone.daylightSavingTime);
                ob_set_n(_timeZone, L"daylightSavingTimeOffset", timezone.daylightSavingTimeOffset);
                ob_set_n(_timeZone, L"secondsFromGMT", timezone.secondsFromGMT);
                ob_set_d(_timeZone, L"nextDaylightSavingTimeTransition", timezone.nextDaylightSavingTimeTransition);
                                
                ob_set_o(_event, L"timeZone", _timeZone);

            }else{
                ob_set_0(_event, L"timeZone");
            }
#else
            ob_set_v(_event, L"uid", event.uid);
            ob_set_u(_event, L"url", event.url);
            ob_set_d(_event, L"occurrence", event.occurrence);
            ob_set_d(_event, L"dateStamp", event.dateStamp);
#endif
            ob_set_v(_event, L"location", event.location);
            ob_set_v(_event, L"notes", event.notes);
            ob_set_v(_event, L"title", event.title);
            
            ob_set_d(_event, L"endDate", event.endDate);
            ob_set_d(_event, L"startDate", event.startDate);

            ob_set_b(_event, L"isAllDay", event.isAllDay);
            ob_set_b(_event, L"isDetached", event.isDetached);
            
            if(with_calendar){
                ob_set_event_calendar(_event, event);
            }
            
            NSArray *alarms = [event alarms];
            
            if(alarms){
                
                PA_CollectionRef _alarms = PA_CreateCollection();

                for(unsigned int i = 0; i < [alarms count]; ++i)
                {
#if USE_EK_CALENDAR_ITEM
                    if([[alarms objectAtIndex:i]isMemberOfClass:[EKAlarm class]])
                    {
                        EKAlarm *alarm = [alarms objectAtIndex:i];
                        
                        PA_ObjectRef _alarm = PA_CreateObject();
                        
                        switch (alarm.type) {
                            case EKAlarmTypeAudio:
                                ob_set_v(_alarm, L"action", @"Sound"); /* CalAlarmActionSound, not "Audio" */
                                break;
                            case EKAlarmTypeDisplay:
                                ob_set_v(_alarm, L"action", @"Display");
                                break;
                            case EKAlarmTypeEmail:
                                ob_set_v(_alarm, L"action", @"Email");
                                break;
                            case EKAlarmTypeProcedure:
                                ob_set_v(_alarm, L"action", @"Procedure");
                                break;
                        }
                        
                        ob_set_v(_alarm, L"emailAddress", alarm.emailAddress);
                        ob_set_v(_alarm, L"sound", alarm.soundName);
                        
                        if(alarm.relativeOffset){
                            ob_set_n(_alarm, L"relativeTrigger", alarm.relativeOffset);
                        }else{
                            ob_set_0(_alarm, L"relativeTrigger");
                        }
                        
                        ob_set_d(_alarm, L"absoluteTrigger", alarm.absoluteDate);
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, _alarm);
                        PA_SetCollectionElement(_alarms, PA_GetCollectionLength(_alarms), v);
                        PA_ClearVariable(&v);
                    }
#else
                    if([[alarms objectAtIndex:i]isMemberOfClass:[CalAlarm class]])
                    {
                        CalAlarm *alarm = [alarms objectAtIndex:i];
                        
                        PA_ObjectRef _alarm = PA_CreateObject();
                        
                        ob_set_v(_alarm, L"action", alarm.action);
                        ob_set_v(_alarm, L"emailAddress", alarm.emailAddress);
                        ob_set_v(_alarm, L"sound", alarm.sound);
                        ob_set_u(_alarm, L"url", alarm.url);
                        
                        if(alarm.relativeTrigger){
                            ob_set_n(_alarm, L"relativeTrigger", alarm.relativeTrigger);
                        }else{
                            ob_set_0(_alarm, L"relativeTrigger");
                        }
                        
                        ob_set_d(_alarm, L"absoluteTrigger", alarm.absoluteTrigger);
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, _alarm);
                        PA_SetCollectionElement(_alarms, PA_GetCollectionLength(_alarms), v);
                        PA_ClearVariable(&v);
                    }
#endif
                    
                }
                
                ob_set_c(_event, L"alarms", _alarms);
            }
            
            NSArray *attendees = [event attendees];
            
            if(attendees){
                
                PA_CollectionRef _attendees = PA_CreateCollection();
                
                for(unsigned int i = 0; i < [attendees count]; ++i)
                {
#if USE_EK_CALENDAR_ITEM
                    if([[attendees objectAtIndex:i]isMemberOfClass:[EKParticipant class]])
                    {
                        EKParticipant *attendee = [attendees objectAtIndex:i];
                        
                        PA_ObjectRef _attendee = PA_CreateObject();
                        
                        ob_set_b(_attendee, L"isCurrentUser", attendee.currentUser);

                        switch (attendee.participantRole) {
                            case EKParticipantRoleNonParticipant:
                                ob_set_v(_attendee, L"role", @"NonParticipant");
                                break;
                            case EKParticipantRoleChair:
                                ob_set_v(_attendee, L"role", @"Chair");
                                break;
                            case EKParticipantRoleOptional:
                                ob_set_v(_attendee, L"role", @"Optional");
                                break;
                            case EKParticipantRoleRequired:
                                ob_set_v(_attendee, L"role", @"Required");
                                break;
                            case EKParticipantRoleUnknown:
                            default:
                                ob_set_v(_attendee, L"role", @"Unknown");
                                break;
                        }
                        
                        switch (attendee.participantType) {
                            case EKParticipantTypeResource:
                                ob_set_v(_attendee, L"type", @"Resource");
                                break;
                            case EKParticipantTypeRoom:
                                ob_set_v(_attendee, L"type", @"Room");
                                break;
                            case EKParticipantTypePerson:
                                ob_set_v(_attendee, L"type", @"Person");
                                break;
                            case EKParticipantTypeGroup:
                                ob_set_v(_attendee, L"type", @"Group");
                                break;
                            case EKParticipantTypeUnknown:
                            default:
                                ob_set_v(_attendee, L"type", @"Unknown");
                                break;
                        }
                        
                        switch (attendee.participantStatus) {
                            case EKParticipantStatusPending:
                                ob_set_v(_attendee, L"status", @"Pending");
                                break;
                            case EKParticipantStatusAccepted:
                                ob_set_v(_attendee, L"status", @"Accepted");
                                break;
                            case EKParticipantStatusDeclined:
                                ob_set_v(_attendee, L"status", @"Declined");
                                break;
                            case EKParticipantStatusTentative:
                                ob_set_v(_attendee, L"status", @"Tentative");
                                break;
                            case EKParticipantStatusDelegated:
                                ob_set_v(_attendee, L"status", @"Delegated");
                                break;
                            case EKParticipantStatusCompleted:
                                ob_set_v(_attendee, L"status", @"Completed");
                                break;
                            case EKParticipantStatusInProcess:
                                ob_set_v(_attendee, L"status", @"InProcess");
                                break;
                            case EKParticipantStatusUnknown:
                            default:
                                ob_set_v(_attendee, L"status", @"Unknown");
                                break;
                        }
                        
                        ob_set_v(_attendee, L"commonName", attendee.name);
                        ob_set_u(_attendee, L"address", attendee.URL);
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, _attendee);
                        PA_SetCollectionElement(_attendees, PA_GetCollectionLength(_attendees), v);
                        PA_ClearVariable(&v);
                    }
#else
                    if([[attendees objectAtIndex:i]isMemberOfClass:[CalAttendee class]])
                    {
                        CalAttendee *attendee = [attendees objectAtIndex:i];
                        
                        PA_ObjectRef _attendee = PA_CreateObject();
                        
                        ob_set_v(_attendee, L"status", attendee.status);
                        ob_set_v(_attendee, L"commonName", attendee.commonName);
                        
                        ob_set_u(_attendee, L"address", attendee.address);
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, _attendee);
                        PA_SetCollectionElement(_attendees, PA_GetCollectionLength(_attendees), v);
                        PA_ClearVariable(&v);
                    }
#endif
  
                }
                
                ob_set_c(_event, L"attendees", _attendees);
            }
           
#if USE_EK_CALENDAR_ITEM
            EKRecurrenceRule *recurrenceRule = nil;
            if([event hasRecurrenceRules]) {
                NSArray<EKRecurrenceRule *> *recurrenceRules = event.recurrenceRules;
                if(recurrenceRules) {
                    if(recurrenceRules.count > 0) {
                        recurrenceRule = recurrenceRules.firstObject;
                    }
                }
            }
#else
            CalRecurrenceRule *recurrenceRule = event.recurrenceRule;
#endif

            if(recurrenceRule){
                
                PA_ObjectRef _recurrenceRule = PA_CreateObject();
#if USE_EK_CALENDAR_ITEM
                ob_set_n(_recurrenceRule, L"recurrenceInterval", recurrenceRule.interval);
                ob_set_n(_recurrenceRule, L"recurrenceType", recurrenceRule.frequency);
#else
                ob_set_n(_recurrenceRule, L"recurrenceInterval", recurrenceRule.recurrenceInterval);
                ob_set_n(_recurrenceRule, L"recurrenceType", recurrenceRule.recurrenceType);
#endif

                ob_set_n(_recurrenceRule, L"firstDayOfTheWeek", recurrenceRule.firstDayOfTheWeek);
                                
                PA_ObjectRef _recurrenceEnd = PA_CreateObject();
                
                if(recurrenceRule.recurrenceEnd){
                    
#if USE_EK_CALENDAR_ITEM
#else
                    ob_set_b(_recurrenceEnd, L"usesEndDate", recurrenceRule.recurrenceEnd.usesEndDate);
#endif
                    ob_set_d(_recurrenceEnd, L"endDate", recurrenceRule.recurrenceEnd.endDate);
                    ob_set_n(_recurrenceEnd, L"occurrenceCount", recurrenceRule.recurrenceEnd.occurrenceCount);
                }
                
                ob_set_o(_recurrenceRule, L"recurrenceEnd", _recurrenceEnd);
                                
                if(recurrenceRule.daysOfTheWeek){
                    PA_CollectionRef _daysOfTheWeek = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.daysOfTheWeek count]; ++i)
                    {
                        PA_Variable v = PA_CreateVariable(eVK_Longint);
                        PA_SetLongintVariable(&v, (PA_long32)[(NSNumber *)[recurrenceRule.daysOfTheWeek objectAtIndex:i]intValue]);
                        PA_SetCollectionElement(_daysOfTheWeek, PA_GetCollectionLength(_daysOfTheWeek), v);
                        PA_ClearVariable(&v);
                    }
                    ob_set_c(_recurrenceRule, L"daysOfTheWeek", _daysOfTheWeek);
                }
                
                if(recurrenceRule.daysOfTheMonth){
                    PA_CollectionRef _daysOfTheMonth = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.daysOfTheMonth count]; ++i)
                    {
                        PA_Variable v = PA_CreateVariable(eVK_Longint);
                        PA_SetLongintVariable(&v, (PA_long32)[(NSNumber *)[recurrenceRule.daysOfTheMonth objectAtIndex:i]intValue]);
                        PA_SetCollectionElement(_daysOfTheMonth, PA_GetCollectionLength(_daysOfTheMonth), v);
                        PA_ClearVariable(&v);
                    }
                    ob_set_c(_recurrenceRule, L"daysOfTheMonth", _daysOfTheMonth);
                }

                if(recurrenceRule.monthsOfTheYear){
                    PA_CollectionRef _monthsOfTheYear = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.monthsOfTheYear count]; ++i)
                    {
                        PA_Variable v = PA_CreateVariable(eVK_Longint);
                        PA_SetLongintVariable(&v, (PA_long32)[(NSNumber *)[recurrenceRule.monthsOfTheYear objectAtIndex:i]intValue]);
                        PA_SetCollectionElement(_monthsOfTheYear, PA_GetCollectionLength(_monthsOfTheYear), v);
                        PA_ClearVariable(&v);
                    }
                    ob_set_c(_recurrenceRule, L"monthsOfTheYear", _monthsOfTheYear);
                }
                
#if USE_EK_CALENDAR_ITEM
                
                if(recurrenceRule.daysOfTheYear){
                    PA_CollectionRef _daysOfTheYear = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.daysOfTheYear count]; ++i)
                    {
                        PA_Variable v = PA_CreateVariable(eVK_Longint);
                        PA_SetLongintVariable(&v, (PA_long32)[(NSNumber *)[recurrenceRule.daysOfTheYear objectAtIndex:i]intValue]);
                        PA_SetCollectionElement(_daysOfTheYear, PA_GetCollectionLength(_daysOfTheYear), v);
                        PA_ClearVariable(&v);
                    }
                    ob_set_c(_recurrenceRule, L"daysOfTheYear", _daysOfTheYear);
                }

                if(recurrenceRule.weeksOfTheYear){
                    PA_CollectionRef _weeksOfTheYear = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.weeksOfTheYear count]; ++i)
                    {
                        PA_Variable v = PA_CreateVariable(eVK_Longint);
                        PA_SetLongintVariable(&v, (PA_long32)[(NSNumber *)[recurrenceRule.weeksOfTheYear objectAtIndex:i]intValue]);
                        PA_SetCollectionElement(_weeksOfTheYear, PA_GetCollectionLength(_weeksOfTheYear), v);
                        PA_ClearVariable(&v);
                    }
                    ob_set_c(_recurrenceRule, L"weeksOfTheYear", _weeksOfTheYear);
                }
                
                if(recurrenceRule.setPositions){
                    PA_CollectionRef _setPositions = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.setPositions count]; ++i)
                    {
                        PA_Variable v = PA_CreateVariable(eVK_Longint);
                        PA_SetLongintVariable(&v, (PA_long32)[(NSNumber *)[recurrenceRule.setPositions objectAtIndex:i]intValue]);
                        PA_SetCollectionElement(_setPositions, PA_GetCollectionLength(_setPositions), v);
                        PA_ClearVariable(&v);
                    }
                    ob_set_c(_recurrenceRule, L"setPositions", _setPositions);
                }
#else
                if(recurrenceRule.nthWeekDaysOfTheMonth){
                    PA_CollectionRef _nthWeekDaysOfTheMonth = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.nthWeekDaysOfTheMonth count]; ++i)
                    {
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        
                        PA_ObjectRef _nthWeekDay = PA_CreateObject();
                        CalNthWeekDay *nthWeekDay = [recurrenceRule.nthWeekDaysOfTheMonth objectAtIndex:i];
                        ob_set_n(_nthWeekDay, L"dayOfTheWeek", nthWeekDay.dayOfTheWeek);
                        ob_set_n(_nthWeekDay, L"weekNumber", nthWeekDay.weekNumber);
                        
                        PA_SetObjectVariable(&v, _nthWeekDay);
                        
                        PA_SetCollectionElement(_nthWeekDaysOfTheMonth, PA_GetCollectionLength(_nthWeekDaysOfTheMonth), v);
                        PA_ClearVariable(&v);
                    }
                    ob_set_c(_recurrenceRule, L"nthWeekDaysOfTheMonth", _nthWeekDaysOfTheMonth);
                }
#endif
  
                ob_set_o(_event, L"recurrenceRule", _recurrenceRule);
            }
        }
    }
}

void ob_set_error(PA_ObjectRef status, NSError *error) {
    
    if(status){
        if(error){
            ob_set_b(status, L"success", false);

            PA_ObjectRef _error = PA_CreateObject();
            
            ob_set_n(_error, L"code", error.code);
            ob_set_v(_error, L"localizedDescription", error.localizedDescription);
            ob_set_v(_error, L"localizedRecoverySuggestion", error.localizedRecoverySuggestion);
            ob_set_o(status, L"error", _error);
        }
    }
}

void ob_add_event(PA_CollectionRef _events,
#if USE_EK_CALENDAR_ITEM
                  EKEvent *event
#else
                  CalEvent *event
#endif
                  ) {

    if(_events){
        if(event){
            PA_ObjectRef _event = PA_CreateObject();
            ob_copy_event(_event, event);
                        
            PA_Variable v = PA_CreateVariable(eVK_Object);
            PA_SetObjectVariable(&v, _event);
            PA_SetCollectionElement(_events, PA_GetCollectionLength(_events), v);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_event(PA_ObjectRef status,
#if USE_EK_CALENDAR_ITEM
                  EKEvent *event
#else
                  CalEvent *event
#endif
                  ) {
    
    if(status){
        if(event){
            PA_ObjectRef _event = PA_CreateObject();
            ob_copy_event(_event, event);
            
            ob_set_o(status, L"event", _event);
        }
    }
}

#pragma mark Event

void iCal_Create_event(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        EKSpan span = EKSpanFutureEvents;
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                if(ob_is_defined(options, L"span")) {
                    CUTF8String _span;
                    if(ob_get_s(options, L"span", &_span)) {
                        if(_span == (const uint8_t *)"future") {
                            span = EKSpanFutureEvents;
                        }
                        if(_span == (const uint8_t *)"this") {
                            span = EKSpanThisEvent;
                        }
                    }
                }
                
                PA_ObjectRef c = ob_get_o(options, L"calendar");
                
                if(c){
                    
#if USE_EK_CALENDAR_ITEM
                        EKCalendar  *calendar = ob_get_calendar(c, defaultCalendarStore);
#else
                        CalCalendar *calendar = ob_get_calendar(c, defaultCalendarStore);
#endif
                                        
                    if(calendar){
                        
#if USE_EK_CALENDAR_ITEM
                        EKEvent  *event = [EKEvent eventWithEventStore:defaultCalendarStore];
#else
                        CalEvent *event = [CalEvent event];
#endif

                        event.calendar = calendar;
                        
                        ob_set_event_prop(status, options, event);
                        
                        NSError *error = nil;
                        
#if USE_EK_CALENDAR_ITEM
                        if([defaultCalendarStore saveEvent:event span:span  commit:YES error:&error])
#else
                        if([defaultCalendarStore saveEvent:event span:CalSpanThisEvent error:&error])
#endif
                        {
                        
                            ob_set_b(status, L"success", true);
                            ob_set_event(status, event);
                            
                        }else{
                            ob_set_error(status, error);
                        }
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "invalid calendar");
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "calendar option is missing");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    PA_ReturnObject(params, status);
}

void iCal_Set_event_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        EKSpan span = EKSpanFutureEvents;
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){

                if(ob_is_defined(options, L"span")) {
                    CUTF8String _span;
                    if(ob_get_s(options, L"span", &_span)) {
                        if(_span == (const uint8_t *)"future") {
                            span = EKSpanFutureEvents;
                        }
                        if(_span == (const uint8_t *)"this") {
                            span = EKSpanThisEvent;
                        }
                    }
                }
                
#if USE_EK_CALENDAR_ITEM
                EKEvent  *event = ob_get_event(options, defaultCalendarStore);
#else
                CalEvent *event = ob_get_event(options, defaultCalendarStore);
#endif
                                
                if(event){
                    
                    PA_ObjectRef c = ob_get_o(options, L"calendar");
                    
                    if(c){
                        
#if USE_EK_CALENDAR_ITEM
                        EKCalendar  *calendar = ob_get_calendar(c, defaultCalendarStore);
#else
                        CalCalendar *calendar = ob_get_calendar(c, defaultCalendarStore);
#endif
                        
                        if(calendar){
                            event.calendar = calendar;
                        }
                    }
                    
                    ob_set_event_prop(status, options, event);

                    NSError *error = nil;
 
#if USE_EK_CALENDAR_ITEM
                    if([defaultCalendarStore saveEvent:event span:span     commit:YES error:&error])
#else
                    if([defaultCalendarStore saveEvent:event span:CalSpanFutureEvents error:&error])
#endif
                    {
                        
                        ob_set_b(status, L"success", true);
                        ob_set_event(status, event);
                        
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid event");
                }
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
            
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    PA_ReturnObject(params, status);
}

void iCal_Get_event_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){

#if USE_EK_CALENDAR_ITEM
                EKEvent  *event = ob_get_event(options, defaultCalendarStore);
#else
                CalEvent *event = ob_get_event(options, defaultCalendarStore);
#endif

                if(event){
                    
                    ob_set_b(status, L"success", true);
                    ob_set_event(status, event);
                                        
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid event");
                }
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    PA_ReturnObject(params, status);
}

void iCal_Remove_event(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        EKSpan span = EKSpanFutureEvents;
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
        
#if USE_EK_CALENDAR_ITEM
                EKEvent  *event = ob_get_event(options, defaultCalendarStore);
                
                if(ob_is_defined(options, L"span")) {
                    CUTF8String _span;
                    if(ob_get_s(options, L"span", &_span)) {
                        if(_span == (const uint8_t *)"future") {
                            span = EKSpanFutureEvents;
                        }
                        if(_span == (const uint8_t *)"this") {
                            span = EKSpanThisEvent;
                        }
                    }
                }
#else
                CalEvent *event = ob_get_event(options, defaultCalendarStore);
#endif
    
                if(event){
                    
                    NSError *error = nil;
                    
#if USE_EK_CALENDAR_ITEM
                    if([defaultCalendarStore removeEvent:event span:span  commit:YES error:&error])
#else
                    if([defaultCalendarStore removeEvent:event span:CalSpanAllEvents error:&error])
#endif
                    {
        
                        ob_set_b(status, L"success", true);
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid event");
                }
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
            
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    PA_ReturnObject(params, status);
}

#pragma mark Calendar

void iCal_Create_calendar(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore     *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
#if USE_EK_CALENDAR_ITEM
                EKCalendar  *calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:defaultCalendarStore];
#else
                CalCalendar *calendar = [CalCalendar calendar];
#endif
                if(calendar) {
                    
                    NSString *title = ob_get_v(options, L"title");
                    
                    if(title){
                        calendar.title = title;
                        [title release];
                    }

#if USE_EK_CALENDAR_ITEM

                    NSArray<EKSource *> *sources = [defaultCalendarStore sources];
                    NSString *source = ob_get_v(options, L"source");
                    
                    if(source) {
                        
                        if(!calendar.source) {
                            calendar.source = [defaultCalendarStore sourceWithIdentifier:source];
                        }
                        
                        if(!calendar.source) {
                            NSPredicate *predicate = [NSPredicate predicateWithFormat:@"%K == %@ or %K LIKE %@",
                                                      @"typeString", source, @"title", source
                                                      ];
                            NSArray *_sources = [sources filteredArrayUsingPredicate:predicate];
                            if([_sources count]){
                                calendar.source = [_sources objectAtIndex:0];
                            }
                        }

                        [source release];
                    }
                    
                    if(!calendar.source) {
                        calendar.source = [defaultCalendarStore sourceWithIdentifier:@"Local"];
                    }
                    
                    if(!calendar.source) {
                        NSPredicate *predicate = [NSPredicate predicateWithFormat:@"%K == %@",
                                                  @"sourceType", [NSNumber numberWithInt:EKSourceTypeLocal]];
                        NSArray *_sources = [sources filteredArrayUsingPredicate:predicate];
                        if([_sources count]){
                            calendar.source = [_sources objectAtIndex:0];
                        }
                    }
                      
#else
                    NSString *notes = ob_get_v(options, L"notes");
                    
                    if(notes){
                        calendar.notes = notes;
                        [notes release];
                    }
#endif

                    if(ob_is_defined(options, L"color")){
                        calendar.color = getRGBcolor(ob_get_n(options, L"color"));
                    }
 
                    NSError *error = nil;
                    
#if USE_EK_CALENDAR_ITEM
                    if([defaultCalendarStore saveCalendar:calendar commit:YES error:&error])
#else
                    if([defaultCalendarStore saveCalendar:calendar error:&error])
#endif
                    {
                        ob_set_b(status, L"success", true);
                        
                        PA_ObjectRef _calendar = PA_CreateObject();
                        
                        ob_set_calendar(_calendar, calendar);

                        ob_set_o(status, L"calendar", _calendar);
                        
                    }else{
                        ob_set_error(status, error);
                    }
  
                }
     
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    
    PA_ReturnObject(params, status);
}

void iCal_Set_calendar_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
#if USE_EK_CALENDAR_ITEM
                EKCalendar  *calendar = ob_get_calendar(options, defaultCalendarStore);
#else
                CalCalendar *calendar = ob_get_calendar(options, defaultCalendarStore);
#endif

                if(calendar){
                    
                    NSString *title = ob_get_v(options, L"title");
                    
                    if(title){
                        calendar.title = title;
                        [title release];
                    }

#if USE_EK_CALENDAR_ITEM
#else
                    NSString *notes = ob_get_v(options, L"notes");
                    
                    if(notes){
                        calendar.notes = notes;
                        [notes release];
                    }
#endif
      
                    if(ob_is_defined(options, L"color")){
                        calendar.color = getRGBcolor(ob_get_n(options, L"color"));
                    }
                    
                    NSError *error = nil;
                    
#if USE_EK_CALENDAR_ITEM
                    if([defaultCalendarStore saveCalendar:calendar commit:YES error:&error])
#else
                    if([defaultCalendarStore saveCalendar:calendar error:&error])
#endif
                    {
   
                        ob_set_b(status, L"success", true);
                        
                        PA_ObjectRef _calendar = PA_CreateObject();
  
                        ob_set_calendar(_calendar, calendar);
                        
                        ob_set_o(status, L"calendar", _calendar);
                        
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid calendar");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    
    PA_ReturnObject(params, status);
}

void iCal_Get_calendar_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
#if USE_EK_CALENDAR_ITEM
                EKCalendar *calendar = ob_get_calendar(options, defaultCalendarStore);
#else
                CalCalendar *calendar = ob_get_calendar(options, defaultCalendarStore);
#endif
                
                if(calendar){
                    
                    PA_ObjectRef _calendar = PA_CreateObject();
 
                    ob_set_calendar(_calendar, calendar);
                    
                    ob_set_o(status, L"calendar", _calendar);
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid calendar");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
            
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    
    PA_ReturnObject(params, status);
}
    
void iCal_Remove_calendar(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {

#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
#if USE_EK_CALENDAR_ITEM
                        EKCalendar *calendar = ob_get_calendar(options, defaultCalendarStore);
#else
                        CalCalendar *calendar = ob_get_calendar(options, defaultCalendarStore);
#endif
                
                if(calendar){
                    NSError *error = nil;
    
#if USE_EK_CALENDAR_ITEM
                    if([defaultCalendarStore removeCalendar:calendar commit:YES error:&error])
#else
                    if([defaultCalendarStore removeCalendar:calendar error:&error])
#endif
                    {
                        ob_set_b(status, L"success", true);
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid calendar");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
        
    }
    PA_ReturnObject(params, status);
}

void iCal_QUERY_EVENT(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
                
        if(defaultCalendarStore) {
            
            PA_CollectionRef _events = PA_CreateCollection();
            
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                NSDate *startDate = ob_get_d(options, L"startDate");
                NSDate *endDate = ob_get_d(options, L"endDate");
                
                if(startDate){
                    if(endDate){
                        
                        NSArray *calendars = ob_get_calendars(options, defaultCalendarStore);
    
#if USE_EK_CALENDAR_ITEM
                        NSPredicate *predicate = [defaultCalendarStore predicateForEventsWithStartDate:startDate
                                                                                               endDate:endDate
                                                                                             calendars:[calendars count] ? calendars : nil];
#else
                        if(calendars){
                            
                            
                            NSPredicate *predicate = [CalCalendarStore eventPredicateWithStartDate:startDate
                                                                                           endDate:endDate
                                                                                         calendars:calendars];
                        }else{
                            ob_set_b(status, L"success", false);
                            ob_set_s(status, L"errorMessage", "invalid calendars");
                        }
#endif
                        if(predicate){
                            
#if USE_EK_CALENDAR_ITEM
                            NSArray *events = [defaultCalendarStore eventsMatchingPredicate:predicate];
#else
                            NSArray *events = [defaultCalendarStore eventsWithPredicate:predicate];
#endif
                            
                            time_t startTime = time(0);
                            
                            for(unsigned int i = 0; i < [events count]; ++i) {
                                
                                time_t now = time(0);
                                time_t elapsedTime = abs(startTime - now);
                                if(elapsedTime > 0)
                                {
                                    startTime = now;
                                    PA_YieldAbsolute();
                                }
                                if([[events objectAtIndex:i]isMemberOfClass:[CalEvent class]]) {
#if USE_EK_CALENDAR_ITEM
                                    EKEvent *event = [events objectAtIndex:i];
#else
                                    CalEvent *event = [events objectAtIndex:i];
#endif
                                    ob_add_event(_events, event);
                                    
                                }
                            }
                            ob_set_c(status, L"events", _events);
                        }else{
                            ob_set_b(status, L"success", false);
                            ob_set_s(status, L"errorMessage", "invalid predicate");
                        }
                        
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "invalid endDate");
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid startDate");
                }
            }
            
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    PA_ReturnObject(params, status);
}
        
void iCal_GET_CALENDAR_LIST(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
#if USE_EK_CALENDAR_ITEM
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
#else
        CalCalendarStore *defaultCalendarStore = [CalCalendarStore defaultCalendarStore];
#endif
        
        if(defaultCalendarStore) {
            
            PA_CollectionRef _calendars = PA_CreateCollection();
            
#if USE_EK_CALENDAR_ITEM
            NSArray *calendars = [defaultCalendarStore calendarsForEntityType:EKEntityTypeEvent];
#else
            NSArray *calendars = [defaultCalendarStore calendars];
#endif

            for(unsigned int i = 0; i < [calendars count]; ++i) {

#if USE_EK_CALENDAR_ITEM
                if([[calendars objectAtIndex:i]isMemberOfClass:[EKCalendar class]])
 #else
                if([[calendars objectAtIndex:i]isMemberOfClass:[CalCalendar class]])
#endif
                {
                    
#if USE_EK_CALENDAR_ITEM
                    EKCalendar *calendar = [calendars objectAtIndex:i];
#else
                    CalCalendar *calendar = [calendars objectAtIndex:i];
#endif
                    
                    PA_ObjectRef _calendar = PA_CreateObject();

                    ob_set_calendar(_calendar, calendar);
                    
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, _calendar);
                    PA_SetCollectionElement(_calendars, PA_GetCollectionLength(_calendars), v);
                    PA_ClearVariable(&v);
                }
                
            }
            
            ob_set_c(status, L"calendars", _calendars);
         
#if USE_EK_CALENDAR_ITEM
            [defaultCalendarStore release];
#endif
        }
    }
    
    PA_ReturnObject(params, status);
}
    
void iCal_Get_default_calendar(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
#if USE_EK_CALENDAR_ITEM
    
    if(check_permission(status)) {
        EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
        
        if(defaultCalendarStore) {
            
            EKCalendar *calendar = defaultCalendarStore.defaultCalendarForNewEvents;

            if(calendar) {
                
                ob_set_b(status, L"success", true);
                
                PA_ObjectRef _calendar = PA_CreateObject();
                
                ob_set_calendar(_calendar, calendar);
                                
                ob_set_o(status, L"calendar", _calendar);
                
                NSArray<EKSource *> *sources = [defaultCalendarStore sources];
                
                PA_CollectionRef _sources = PA_CreateCollection();
                
                for(NSUInteger i = 0; i < [sources count]; ++i) {
                    
                    EKSource *source = [sources objectAtIndex:i];
                    
                    PA_ObjectRef s = PA_CreateObject();

                    ob_set_v(s, L"uid", source.sourceIdentifier);
                    ob_set_v(s, L"title", source.title);
                    
                    switch (source.sourceType) {
                        case EKSourceTypeLocal:
                            ob_set_v(s, L"type", @"Local");
                            break;
                        case EKSourceTypeCalDAV:
                            ob_set_v(s, L"type", @"CalDAV");
                            break;
                        case EKSourceTypeExchange:
                            ob_set_v(s, L"type", @"Exchange");
                            break;
                        case EKSourceTypeSubscribed:
                            ob_set_v(s, L"type", @"Subscription");
                            break;
                        case EKSourceTypeBirthdays:
                            ob_set_v(s, L"type", @"Birthday");
                            break;
                        case EKSourceTypeMobileMe:
                            ob_set_v(s, L"type", @"MobileMe");
                            break;
                    }
                    
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, s);
                    PA_SetCollectionElement(_sources, PA_GetCollectionLength(_sources), v);
                    PA_ClearVariable(&v);
  
                }
 
                ob_set_c(status, L"sources", _sources);
            }
            [defaultCalendarStore release];
        }
        
    }
#endif
    
    PA_ReturnObject(params, status);
}
    
#pragma GCC diagnostic pop
